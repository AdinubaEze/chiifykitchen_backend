<?php

namespace App\Http\Controllers;

use App\Models\Category;
use App\Models\ActivityLog;
use App\Http\Requests\CategoryRequest;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Cache;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Validator;
 
class CategoryController extends Controller
{
    public function __construct()
    {
        // Only apply auth middleware to these methods
        $this->middleware('auth:api')->only(['store', 'update', 'destroy']);
        
        // Only admin can access these methods
        $this->middleware('role:admin')->only(['store', 'update', 'destroy']);
    }
    
    public function index(Request $request)
{
    try {
        // Generate a unique cache key based on request parameters
        $cacheKey = 'categories_' . md5(serialize($request->all()));
        
        // Return cached data if available
        if (Cache::has($cacheKey)) {
            return response()->json([
                'status' => 'success',
                'message' => 'Cached categories retrieved',
                'data' => Cache::get($cacheKey)
            ]);
        }

        $query = Category::with('admin');

        // Search functionality
        if ($request->has('search')) {
            try {
                $search = $request->input('search');
                if (!is_string($search)) {
                    throw new \InvalidArgumentException('Search parameter must be a string');
                }
                
                $query->where(function($q) use ($search) {
                    $q->where('name', 'like', "%{$search}%")
                      ->orWhere('description', 'like', "%{$search}%");
                });
            } catch (\Exception $e) {
                Log::error('Search failed', [
                    'error' => $e->getMessage(),
                    'search' => $request->input('search')
                ]);
                // Continue without search rather than failing completely
            }
        }

        // Filter by status
        if ($request->has('status')) {
            try {
                $status = $request->input('status');
                if (!in_array($status, [Category::STATUS_ACTIVE, Category::STATUS_INACTIVE])) {
                    throw new \InvalidArgumentException('Invalid status value');
                }
                $query->where('status', $status);
            } catch (\Exception $e) {
                Log::error('Status filter failed', [
                    'error' => $e->getMessage(),
                    'status' => $request->input('status')
                ]);
                // Continue without status filter
            }
        }

        // Sorting
        try {
            $sortField = $request->input('sort_by', 'created_at');
            $sortDirection = $request->input('sort_dir', 'desc');
            
            // Validate sort fields to prevent SQL injection
            $validSortFields = ['name', 'status', 'created_at', 'updated_at'];
            if (!in_array($sortField, $validSortFields)) {
                $sortField = 'created_at';
            }
            
            // Validate sort direction
            if (!in_array(strtolower($sortDirection), ['asc', 'desc'])) {
                $sortDirection = 'desc';
            }
            
            $query->orderBy($sortField, $sortDirection);
        } catch (\Exception $e) {
            Log::error('Sorting failed', [
                'error' => $e->getMessage(),
                'sort_by' => $request->input('sort_by'),
                'sort_dir' => $request->input('sort_dir')
            ]);
            // Default sorting
            $query->orderBy('created_at', 'desc');
        }

        // Pagination
        try {
            $perPage = $request->input('per_page', 15);
            $perPage = min(max((int)$perPage, 1), 100); // Ensure between 1 and 100
            
            $categories = $query->paginate($perPage);
        } catch (\Exception $e) {
            Log::error('Pagination failed', [
                'error' => $e->getMessage(),
                'per_page' => $request->input('per_page')
            ]);
            // Fallback to default pagination
            $categories = $query->paginate(15);
        }

        // Cache the results
        try {
            Cache::put($cacheKey, $categories, now()->addMinutes(30));
        } catch (\Exception $e) {
            Log::error('Caching failed', [
                'error' => $e->getMessage(),
                'cacheKey' => $cacheKey
            ]);
            // Continue without caching rather than failing the request
        }

        return response()->json([
            'status' => 'success',
            'data' => $categories
        ]);

    } catch (\Throwable $e) {
        // Catch any unexpected errors
        Log::critical('Category index failed', [
            'error' => $e->getMessage(),
            'trace' => $e->getTraceAsString(),
            'request' => $request->all()
        ]);
        
        return response()->json([
            'status' => 'error',
            'message' => 'Unable to retrieve categories',
            'error' => config('app.debug') ? $e->getMessage() : null
        ], 500);
    }
}

    public function store(Request $request)
{
    // Validate the request data
    $validator = Validator::make($request->all(), [
        'name' => 'required|string|max:255|unique:categories,name',
        'description' => 'nullable|string|max:1000',
        'status' => 'required|in:0,1',
        'icon_image' => 'nullable|image|mimes:jpeg,png,jpg,gif,svg|max:2048',
        'meta_title' => 'nullable|string|max:255',
        'meta_description' => 'nullable|string|max:500',
        'meta_keywords' => 'nullable|string|max:255',
    ]);

    // Return validation errors if any
    if ($validator->fails()) {
        $errors = [];
        foreach ($validator->errors()->messages() as $field => $messages) {
            $errors[$field] = $messages[0];
        }
        
        return response()->json([
            'status' => 'error',
            'message' => 'Validation failed',
            'errors' => $errors
        ], 422);
    }


    DB::beginTransaction(); 
    try {

        // Prepare data
        $data = $validator->validated();
        $data['admin_id'] = auth()->id();

        // Handle file upload with proper validation
        if ($request->hasFile('icon_image')) {
            try {
                $file = $request->file('icon_image');
                
                // Additional file validation
                if (!$file->isValid()) {
                    throw new \Exception('Invalid file upload');
                }

                $path = $file->store('category_icons', 'public');
                $data['icon_image'] = $path;
            } catch (\Exception $e) {
                return response()->json([
                    'status' => 'error',
                    'message' => 'File upload failed',
                    'error' => $e->getMessage()
                ], 422);
            }
        }

        // Create category
        $category = Category::create($data);

        // Log the activity
        ActivityLog::create([
            'user_id' => auth()->id(),
            'action' => 'create',
            'model' => 'Category',
            'model_id' => $category->id,
            'changes' => json_encode($category->toArray())
        ]);

        // Clear relevant cache
        Cache::forget('categories_active');
        Cache::forget('categories_all');

        DB::commit();

        return response()->json([
            'status' => 'success',
            'message' => 'Category created successfully',
            'data' => $category
        ], 201);

    } catch (\Exception $e) {
        DB::rollBack();
        
        Log::error('Category creation failed: ' . $e->getMessage(), [
            'exception' => $e,
            'request' => $request->all()
        ]);

        return response()->json([
            'status' => 'error',
            'message' => 'Failed to create category',
            'error' => config('app.debug') ? $e->getMessage() : 'Internal server error'
        ], 500);
    }
}



    
    public function show($id)
    {
        $cacheKey = 'category_' . $id;
        
        if (Cache::has($cacheKey)) {
            $category = Cache::get($cacheKey);
            // Check if category is active (if you want to hide inactive from public)
            if ($category->status == Category::STATUS_INACTIVE && !auth()->check()) {
                return response()->json([
                    'status' => 'error',
                    'message' => 'Category not available'
                ], 404);
            }
            
            return response()->json([
                'status' => 'success',
                'message' => 'Cached category retrieved',
                'data' => $category
            ]);
        }
    
        $category = Category::with('admin')->find($id);
        
        if (!$category) {
            return response()->json([
                'status' => 'error',
                'message' => 'Category not found'
            ], 404);
        }
    
        // Optional: Hide inactive categories from public
        if ($category->status == Category::STATUS_INACTIVE && !auth()->check()) {
            return response()->json([
                'status' => 'error',
                'message' => 'Category not available'
            ], 404);
        }
    
        Cache::put($cacheKey, $category, now()->addMinutes(30));
    
        return response()->json([
            'status' => 'success',
            'data' => $category
        ]);
    }

   public function update(Request $request, $id)
{
    DB::beginTransaction();

    try {
        $category = Category::find($id);
        
        if (!$category) {
            return response()->json([
                'status' => 'error',
                'message' => 'Category not found'
            ], 404);
        }

        // Validate the request data with unique name check ignoring current category
        $validator = Validator::make($request->all(), [
            'name' => 'sometimes|required|string|max:255|unique:categories,name,'.$category->id,
            'description' => 'nullable|string|max:1000',
            'status' => 'sometimes|required|in:0,1',
            'icon_image' => 'nullable|image|mimes:jpeg,png,jpg,gif,svg|max:2048',
            'meta_title' => 'nullable|string|max:255',
            'meta_description' => 'nullable|string|max:500',
            'meta_keywords' => 'nullable|string|max:255',
        ]);

        // Return validation errors if any
        if ($validator->fails()) {
            $errors = [];
            foreach ($validator->errors()->messages() as $field => $messages) {
                $errors[$field] = $messages[0];
            }
            
            return response()->json([
                'status' => 'error',
                'message' => 'Validation failed',
                'errors' => $errors
            ], 422);
        }

        $oldData = $category->toArray();
        $data = $validator->validated();

        // Handle file upload with proper validation
        if ($request->hasFile('icon_image')) {
            try {
                $file = $request->file('icon_image');
                
                // Additional file validation
                if (!$file->isValid()) {
                    throw new \Exception('Invalid file upload');
                }

                // Delete old image if exists
                if ($category->icon_image) {
                    Storage::disk('public')->delete($category->icon_image);
                }

                $path = $file->store('category_icons', 'public');
                $data['icon_image'] = $path;
            } catch (\Exception $e) {
                DB::rollBack();
                return response()->json([
                    'status' => 'error',
                    'message' => 'File upload failed',
                    'error' => $e->getMessage()
                ], 422);
            }
        }

        // Update category
        $category->update($data);

        // Log the activity
        ActivityLog::create([
            'user_id' => auth()->id(),
            'action' => 'update',
            'model' => 'Category',
            'model_id' => $category->id,
            'changes' => json_encode([
                'old' => $oldData,
                'new' => $category->toArray()
            ])
        ]);

        // Clear relevant cache
        Cache::forget('category_' . $id);
        Cache::forget('categories_active');
        Cache::forget('categories_all');

        DB::commit();

        return response()->json([
            'status' => 'success',
            'message' => 'Category updated successfully',
            'data' => $category
        ]);

    } catch (\Exception $e) {
        DB::rollBack();
        
        Log::error('Category update failed: ' . $e->getMessage(), [
            'exception' => $e,
            'request' => $request->all(),
            'category_id' => $id
        ]);

        return response()->json([
            'status' => 'error',
            'message' => 'Failed to update category',
            'error' => config('app.debug') ? $e->getMessage() : 'Internal server error'
        ], 500);
    }
}

    public function destroy($id)
{
    // Validate ID is numeric and positive
    if (!is_numeric($id) || $id <= 0) {
        return response()->json([
            'status' => 'error',
            'message' => 'Invalid category ID'
        ], 400);
    }

    DB::beginTransaction();

    try {
        $category = Category::find($id);
        
        if (!$category) {
            return response()->json([
                'status' => 'error',
                'message' => 'Category not found'
            ], 404);
        }

        // Check if category has associated products
        if (method_exists($category, 'products') && $category->products()->exists()) {
            return response()->json([
                'status' => 'error',
                'message' => 'Cannot delete category with associated products'
            ], 422);
        }

        // Delete associated image if exists
        if ($category->icon_image) {
            try {
                if (!Storage::disk('public')->exists($category->icon_image)) {
                    Log::warning('Category icon not found during deletion', [
                        'category_id' => $id,
                        'icon_path' => $category->icon_image
                    ]);
                } else {
                    Storage::disk('public')->delete($category->icon_image);
                }
            } catch (\Exception $e) {
                DB::rollBack();
                Log::error('Failed to delete category icon', [
                    'error' => $e->getMessage(),
                    'category_id' => $id,
                    'icon_path' => $category->icon_image
                ]);
                
                return response()->json([
                    'status' => 'error',
                    'message' => 'Failed to delete category icon',
                    'error' => config('app.debug') ? $e->getMessage() : null
                ], 500);
            }
        }

        // Create a copy of the category data for logging
        $categoryData = $category->toArray();

        // Log the activity before deletion
        ActivityLog::create([
            'user_id' => auth()->id(),
            'action' => 'delete',
            'model' => 'Category',
            'model_id' => $category->id,
            'changes' => json_encode($categoryData)
        ]);

        // Perform deletion
        if (!$category->delete()) {
            throw new \Exception('Failed to delete category from database');
        }

        // Clear relevant cache
        try {
            Cache::forget('category_' . $id);
            Cache::forget('categories_active');
            Cache::forget('categories_all');
        } catch (\Exception $e) {
            Log::error('Cache clearing failed after category deletion', [
                'error' => $e->getMessage(),
                'category_id' => $id
            ]);
            // Continue despite cache clearing failure
        }

        DB::commit();

        return response()->json([
            'status' => 'success',
            'message' => 'Category deleted successfully'
        ]);

    } catch (\Exception $e) {
        DB::rollBack();
        
        Log::error('Category deletion failed', [
            'error' => $e->getMessage(),
            'trace' => $e->getTraceAsString(),
            'category_id' => $id,
            'user_id' => auth()->id()
        ]);

        return response()->json([
            'status' => 'error',
            'message' => 'Failed to delete category',
            'error' => config('app.debug') ? $e->getMessage() : null
        ], 500);
    }
}

    // Additional method to get frequently accessed categories
    public function frequent()
    {
        $cacheKey = 'categories_frequent';
        
        if (Cache::has($cacheKey)) {
            return response()->json([
                'status' => 'success',
                'message' => 'Cached frequent categories retrieved',
                'data' => Cache::get($cacheKey)
            ]);
        }
    
        try {
            // Check if the products relationship exists
            if (!method_exists(Category::class, 'products')) {
                throw new \Exception('Products relationship not defined on Category model');
            }
    
            $categories = Category::query()
                ->withCount('products')
                ->orderBy('products_count', 'desc')
                ->limit(5)
                ->get();
    
            Cache::put($cacheKey, $categories, now()->addHours(6));
    
            return response()->json([
                'status' => 'success',
                'data' => $categories
            ]);
    
        } catch (\Exception $e) {
            // Fallback to basic categories if products count fails
            Log::error('Failed to get frequent categories: ' . $e->getMessage());
            
            $categories = Category::query()
                ->orderBy('created_at', 'desc')
                ->limit(5)
                ->get();
    
            return response()->json([
                'status' => 'success',
                'data' => $categories,
                'message' => 'Showing recent categories instead of frequent ones'
            ]);
        }
    }
}